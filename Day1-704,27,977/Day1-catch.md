# 关于二分查找

- **最重要的就是分类讨论好二分**  
  二分看着好写，但边界 case 还是需要测试的。

- **什么是区间不变量？**  
  比如区间取左闭右闭的话，那么每次区间二分范围都是新区间的左闭右闭。后面做判断时，要一直基于这个左闭右闭的区间。

- **区间定义成开或者闭都没有关系**  
  只是要明确每次收缩范围后，范围内的元素是哪些，注意会不会漏掉边界就好。

- **大家需要注意二分的几种情况：**  
  - 当 `l = 0, r = n` 的时候，因为 `r` 这个值我们在数组中无法取到，`while(l < r)` 是正确写法。
  - 当 `l = 0, r = n - 1` 的时候，因为 `r` 这个值我们在数组中可以取到，`while(l <= r)` 是正确写法。主要看能不能取到这个值。

- **二分法有多种写法**  
  末尾是开区间还是闭区间都可以解出寻找单个元素和寻找边界的题目，只需要注意相应的是 `l < r` 还是 `l <= r`，每次取 `mid` 还是取 `mid` 加减一即可。建议理解后背熟一套模板，不要搞混。

- **二分的应用场景**  
  二分还有很多应用场景，有着许多变体，比如说查找第一个大于 `target` 的元素或者第一个满足条件的元素，都是一样的。根据是否满足题目的条件来缩小答案所在的区间，这个就是二分的本质。另外需要注意，二分的使用前提是：**有序数组**。

- **二分的最大优势**  
  时间复杂度是 `O(logn)`，因此看到有序数组都要第一时间反问自己是否可以使用二分。

- **关于二分 `mid` 溢出问题解答：**  
  - `mid = (l + r) / 2` 时，如果 `l + r` 大于 `INT_MAX`（C++ 中，即 `int` 整型的上限），那么就会产生溢出问题（`int` 类型无法表示该数）。
  - 所以写成 `mid = l + (r - l) / 2` 或者 `mid = l + ((r - l) >> 1)` 可以避免溢出问题。

- **位运算的好处**  
  对于二进制的正数来说，右移 `x` 位相当于除以 `2^x`，所以右移一位等于除以 2。用位运算的好处是比直接相除的操作快。

---

# 关于移除元素

- **快指针和慢指针的理解**  
  快指针可以理解成在旧数组中找非目标元素，然后赋值给慢指针指向的新数组，虽然都指向一个数组。

- **关于二分法和移除元素的共性思考**  
  这两题之间有点类似，它们都是在不断缩小 `left` 和 `right` 之间的距离，每次需要判断的都是 `left` 和 `right` 之间的数是否满足特定条件。  
  对于「移除元素」这个写法本质上还可以理解为，我们拿 `right` 的元素（右边的元素），去填补 `left` 的元素（左边的元素）的坑。坑就是 `left` 从左到右遍历过程中遇到的需要删除的数。因为题目最后说超过数组长度的右边的数可以不用理，所以其实我们的视角是以 `left` 为主，这样想可能更直观一点。  
  用填补的思想的话可能会修改元素相对位置，这个也是题目所允许的。

- **关于 `fast < nums.size()` 和 `fast <= nums.size() - 1` 的区别**  
  - 两者没什么区别，但为什么第二个会在空数组时报数组越界的错误？  
    `vector` 的 `size()` 函数返回值是无符号整数，空数组时返回了 `0`，再减个 `1` 会溢出，变成一个很大的正数，`nums[fast]` 会发生 `null pointer of type 'int'` 异常。